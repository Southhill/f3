NOTES 4: <<The Art Of Multiprocess Programming>>

## 原理

#### 互斥

**时间**：

- 分析并发计算的实质就是分析时间。有时希望事件同时发生，有时希望事件在不同时间发生。需要对各种复杂情形进行分析，包括多个时间片应该怎样交叉重叠，或者相互之间不允许重叠
- 所有线程共享一个共同的时间（不必是一个公共时钟）。一个线程是一个状态机，其状态的转换称为事件
- 事件是瞬时的：它们在单个瞬间发生。线程A产生了一个事件序列a0,a1,...
- aij表示ai事件的第j次发生
- 事件a在事件b之前发生，则称a先于b，记作a->b
- 令a0和a1表示事件，且a0->a1，则IA=interval(a0,a1)表示a0和a1之间的间隔。
- 如果a0->a1->b0->b1,則interval(a0,a1)->interval(b0,b1)，即IA->IB
- IAj表示IA的第j次执行

**临界区**:
- 两个线程同时访问`start of danger zone`和`end of danger zone`之间的共享变量，就出现资源竞争
- 某个时刻仅能允许一个线程访问`start of danger zone`和`end of danger zone`之间的资源，则构成了一个临界区
	1. 一个临界区只和一个唯一的Lock对象相关联
	2. 线程准备进入临界区时调用该对象的Lock方法
	3. 当线程离开临界区时调用UnLock方法
- 令CS(A,j)是A第j次执行临界区的时间段

**锁**：
- 互斥：不同线程的临界区之间没有重叠。对于线程A、B以及整数j、k，或者CS(A,k)->CS(B,j)或者CS(B,j)->CS(A,k)
- 无死锁：如果一个线程正在尝试获得一个锁，那么， 总会成功地获得这个锁。若线程A调用Lock但无法获得锁，则一定存在其他线程正在无穷次地执行临界区。
- 无饥饿：每个试图获得锁的线程最终都能成功。每个Lock调用最终都能返回。

**各种锁**：
- LockOne
- LockTwo
- Peterson
- Filter
- Bakery

**有界时间戳**：

**存储单元数量的下届**：

#### 并发对象

#### 共享存储基础

#### 同步原子操作的相对能力

#### 一致性的通用性

## 实践

#### 自旋锁与争用

#### 管道和阻塞同步

#### 链表：锁的作用

#### 并行队列和ABA问题

#### 并发栈和消除

#### 计数、排序和分布式协作

#### 并发哈希和固有并行

#### 跳表和平衡查找

#### 优先级队列

#### 异步执行、调度和工作分配

#### 障碍

#### 事物内存